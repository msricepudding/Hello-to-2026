<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2025 跨年 3D 互动相册</title>
    <style>
        body { margin: 0; background: #000005; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #E0A39A; z-index: 10;
        }
        button {
            padding: 15px 40px; font-size: 18px; cursor: pointer;
            background: transparent; border: 2px solid #E0A39A; color: #E0A39A;
            border-radius: 30px; transition: all 0.3s;
        }
        button:hover { background: #E0A39A; color: #000; box-shadow: 0 0 20px #E0A39A; }
        #status { position: absolute; bottom: 20px; left: 20px; color: rgba(224, 163, 154, 0.6); font-size: 12px; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1 style="letter-spacing: 5px; font-weight: 200;">NEW YEAR INTERACTIVE</h1>
        <button id="startBtn">开启 3D 互动体验</button>
    </div>
    <div id="status">MediaPipe: 准备就绪 | 视角: 视差跟随已开启</div>
    <video id="video" style="display:none;" autoplay playsinline></video>
    <canvas id="main-canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, coreLight, heartGroup, stars;
        const photos = [];
        let isExploded = false;
        let mouseX = 0, mouseY = 0;

        // 初始化场景
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000005, 0.015);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('main-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // 核心脉冲光源
            coreLight = new THREE.PointLight(0xFFD700, 10, 60);
            scene.add(coreLight);

            // 星钻粒子
            const starGeo = new THREE.BufferGeometry();
            const starCoords = [];
            for(let i=0; i<3000; i++) starCoords.push((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*150);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true }));
            scene.add(stars);

            createHeartAlbum();
            animate();
        }

        function createHeartAlbum() {
            heartGroup = new THREE.Group();
            scene.add(heartGroup);

            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xE0A39A, metalness: 0.8, roughness: 0.2, emissive: 0x221111 
            });

            for(let i=0; i<21; i++) {
                const group = new THREE.Group();
                const photo = new THREE.Mesh(new THREE.PlaneGeometry(3, 4), new THREE.MeshBasicMaterial({ color: 0x333333 }));
                const frame = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4.2, 0.1), mat);
                frame.position.z = -0.1;
                group.add(photo, frame);

                // 立体爱心参数方程
                const t = (i / 21) * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                group.position.set(x * 0.8, y * 0.8, (Math.random()-0.5)*5);
                group.userData = { 
                    homePos: group.position.clone(), 
                    targetPos: new THREE.Vector3(),
                    rotSpeed: new THREE.Vector3(Math.random()*0.02, Math.random()*0.02, Math.random()*0.02)
                };
                photos.push(group);
                heartGroup.add(group);
            }
        }

        function triggerExplode() {
            isExploded = true;
            photos.forEach(p => {
                p.userData.targetPos.set((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
            });
        }

        function triggerAssemble() { isExploded = false; }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.002;

            // 心跳律动
            const s = 1 + Math.sin(time * 3) * 0.03;
            heartGroup.scale.set(s, s, s);
            coreLight.intensity = 10 + Math.sin(time * 5) * 5;

            photos.forEach(p => {
                const target = isExploded ? p.userData.targetPos : p.userData.homePos;
                p.position.lerp(target, 0.05);
                if(isExploded) {
                    p.rotation.x += p.userData.rotSpeed.x;
                    p.rotation.y += p.userData.rotSpeed.y;
                } else {
                    p.rotation.set(0,0,0);
                }
            });

            // 视差
            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (-mouseY - camera.position.y) * 0.05;
            camera.lookAt(0,0,0);

            renderer.render(scene, camera);
        }

        // MediaPipe 集成
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
        hands.onResults(res => {
            if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                const lm = res.multiHandLandmarks[0];
                mouseX = (lm[9].x - 0.5) * 40;
                mouseY = (lm[9].y - 0.5) * 40;
                
                const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                if(dist > 0.4) triggerExplode(); 
                else if(dist < 0.2) triggerAssemble();
            }
        });

        document.getElementById('startBtn').onclick = () => {
            document.getElementById('overlay').style.display = 'none';
            initScene();
            const cameraHelper = new Camera(document.getElementById('video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('video')}); },
                width: 640, height: 480
            });
            cameraHelper.start();
        };
    </script>
</body>
</html>